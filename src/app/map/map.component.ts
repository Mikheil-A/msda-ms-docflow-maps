import {
  Component,
  OnInit,
  Input,
  Output,
  EventEmitter,
  ElementRef,
  AfterViewInit,
} from '@angular/core';
import { HttpClient } from '@angular/common/http';

import Map from 'ol/Map';
import VectorLayer from 'ol/layer/Vector';
import Tile from 'ol/layer/Tile';
import { Vector } from 'ol/source';
import { Draw, Modify, Snap } from 'ol/interaction';
import OSM from 'ol/source/OSM';
import WKT from 'ol/format/WKT';
import Feature from 'ol/Feature';
import Point from 'ol/geom/Point';
import GeometryType from 'ol/geom/GeometryType';
import * as ol from 'ol/proj';
import View from 'ol/View';

@Component({
  selector: '[openlayers]',
  templateUrl: './map.component.html',
  styleUrls: ['./map.component.scss'],
})
export class MapComponent implements AfterViewInit {
  @Input() orgId = 1;
  @Input() clientToken = 'aceeb1c1-b378-439e-821a-843abcabaafc';
  @Input() center = ol.transform([44.7805792, 41.7128489], 'EPSG:4326', 'EPSG:3857');

  @Output() featureClick = new EventEmitter();

  private _map: Map;
  private _markersLayer: VectorLayer;
  private _drawingLayer: VectorLayer;
  private _drawingInteraction: Draw;

  get map() {
    return this._map;
  }

  constructor(private _http: HttpClient, private _elementRef: ElementRef) {}

  ngAfterViewInit() {
    this._initMap();
    this._initMarkersLayer();
    this._initDrawingLayer();
  }

  addOlInteraction() {
    this._addMesaureTool('Polygon', (e: any) => {
      const format = new WKT();
      const geometry = e.feature.getGeometry();
      const size = this._map.getSize();
      this._map.getView().fit(geometry.getExtent(), { size });
      const wktGeometry = format.writeGeometry(geometry);

      console.log('wktGeometry generated by interaction: ', wktGeometry); // post this string somewhere
    });
  }

  private _initMarkersLayer() {
    this._markersLayer = new VectorLayer({
      zIndex: 2,
      source: new Vector(),
    });

    this._map.addLayer(this._markersLayer);
  }

  private _initDrawingLayer() {
    this._drawingLayer = new VectorLayer({
      zIndex: 1,
      source: new Vector({ wrapX: false }),
    });

    this._map.addLayer(this._drawingLayer);
  }

  private _initMap() {
    this._map = new Map({
      target: this._elementRef.nativeElement,
      view: new View({
        zoom: 14,
        maxZoom: 22,
        center: this.center,
      }),
    });

    console.log(333, this._map, this._elementRef.nativeElement);

    this._http
      .post('/tbilisimap-core/api/managelayersws/getLayersInGroups', {
        params: { orgId: this.orgId, viewLevel: 1 },
        clientToken: this.clientToken,
      })
      .subscribe((res: any) => {
        Array.prototype.forEach.call(res.data[0].lrs, (lr) => {
          if (!lr.sourceUrl) return;
          this.map.addLayer(
            new Tile({
              visible: Boolean(lr.isSelected),
              source: new OSM({
                url: lr.sourceUrl.replace(/\$(\{[xyz]\})/g, '$1'),
                maxZoom: lr.paramsJson.numZoomLevels,
                crossOrigin: null,
              }),
            })
          );
        });
      });
  }

  drawWkt(geometryWkt: string, clear = true) {
    console.log('geometryWkt', geometryWkt);
    if (!geometryWkt) return;

    const source = this._drawingLayer.getSource();

    if (clear) {
      source.clear();
    }

    const format = new WKT();
    const geometry = format.readGeometry(geometryWkt.replace(/,\)$/g, ')'));
    const feature = new Feature({ geometry });

    source.addFeature(feature);

    if (geometry instanceof Point) {
      const center = geometry.getCoordinates();
      this._map.getView().animate({ center, zoom: 18 });
    } else {
      const size = this._map.getSize();
      this._map.getView().fit(geometry.getExtent(), { size });
    }
  }

  private _addInteraction(type: GeometryType) {
    this._removeInteraction();

    const source = this._drawingLayer.getSource();
    this._drawingInteraction = new Draw({ type, source });
    this._map.addInteraction(this._drawingInteraction);

    return this._drawingInteraction;
  }

  private _removeInteraction() {
    if (!this._drawingInteraction) return;

    this._map.removeInteraction(this._drawingInteraction);
    this._drawingInteraction = null;
  }

  removeInteraction() {
    this._map.removeInteraction(this._drawingInteraction);
    this._drawingInteraction = null;
  }

  private _addMesaureTool(type: any, onDrawEnd: any) {
    const source = this._drawingLayer.getSource();

    source.clear();

    const interaction = this._addInteraction(type);

    interaction.on('drawstart', () => {
      source.clear();
    });

    interaction.on('drawend', onDrawEnd);

    return interaction;
  }
}
